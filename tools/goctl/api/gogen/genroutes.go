package gogen

import (
	"fmt"
	"os"
	"path"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/zeromicro/go-zero/core/collection"
	"github.com/zeromicro/go-zero/tools/goctl/api/spec"
	"github.com/zeromicro/go-zero/tools/goctl/config"
	"github.com/zeromicro/go-zero/tools/goctl/util/format"
	"github.com/zeromicro/go-zero/tools/goctl/util/pathx"
)

const (
	jwtTransKey    = "jwtTransition"
	routesFilename = "routes"
	routesTemplate = `// Code generated by ginctl. DO NOT EDIT.

package handler

import (
	"net/http"{{if .hasTimeout}}
	"time"{{end}}
	"github.com/gin-gonic/gin"

	{{.importPackages}}
)

func RegisterHandlers(r *gin.Engine, serverCtx *svc.ServiceContext) {
	{{.routesAdditions}}
}
`
	routesAdditionTemplate = `
	g{{.index}} := r.Group("{{.prefix}}")
	{{.routes}}
	
`
)

var mapping = map[string]string{
	"delete":  "http.MethodDelete",
	"get":     "http.MethodGet",
	"head":    "http.MethodHead",
	"post":    "http.MethodPost",
	"put":     "http.MethodPut",
	"patch":   "http.MethodPatch",
	"connect": "http.MethodConnect",
	"options": "http.MethodOptions",
	"trace":   "http.MethodTrace",
}

type (
	group struct {
		routes           []route
		jwtEnabled       bool
		signatureEnabled bool
		sseEnabled       bool
		authName         string
		timeout          string
		middlewares      []string
		prefix           string
		jwtTrans         string
		maxBytes         string
	}
	route struct {
		method  string
		path    string
		handler string
		doc     string
	}
)

func genRoutes(dir, rootPkg string, cfg *config.Config, api *spec.ApiSpec) error {
	var builder strings.Builder
	groups, err := getRoutes(api)
	if err != nil {
		return err
	}

	templateText, err := pathx.LoadTemplate(category, routesAdditionTemplateFile, routesAdditionTemplate)
	if err != nil {
		return err
	}

	var hasMiddleware bool
	gt := template.Must(template.New("groupTemplate").Parse(templateText))
	for i, g := range groups {
		var gbuilder strings.Builder
		// 中间件
		if len(g.middlewares) > 0 {
			hasMiddleware = true
			params := g.middlewares
			for _, v := range params {
				fmt.Fprintf(&gbuilder, `g%d.Use(middleware.New%sMiddleware().Handle(serverCtx))
`, i, v)
			}
		}
		// group 下的子路由
		for _, r := range g.routes {
			fmt.Fprintf(&gbuilder, `g%d.Handle(%s,"%s",%s)
`, i, r.method, r.path, r.handler)
		}

		var routes string
		routes = strings.TrimSpace(gbuilder.String())

		if err := gt.Execute(&builder, map[string]string{
			"index":  strconv.Itoa(i),
			"routes": routes,
			"prefix": g.prefix,
		}); err != nil {
			return err
		}
	}

	routeFilename, err := format.FileNamingFormat(cfg.NamingFormat, routesFilename)
	if err != nil {
		return err
	}

	routeFilename = routeFilename + ".go"
	filename := path.Join(dir, handlerDir, routeFilename)
	os.Remove(filename)

	return genFile(fileGenConfig{
		dir:             dir,
		subdir:          handlerDir,
		filename:        routeFilename,
		templateName:    "routesTemplate",
		category:        category,
		templateFile:    routesTemplateFile,
		builtinTemplate: routesTemplate,
		data: map[string]any{
			"importPackages":  genRouteImports(rootPkg, hasMiddleware, api),
			"routesAdditions": strings.TrimSpace(builder.String()),
		},
	})
}

func genRouteImports(parentPkg string, hasMiddleware bool, api *spec.ApiSpec) string {
	importSet := collection.NewSet[string]()
	importSet.Add(fmt.Sprintf("\"%s\"", pathx.JoinPackages(parentPkg, contextDir)))
	for _, group := range api.Service.Groups {
		for _, route := range group.Routes {
			folder := route.GetAnnotation(groupProperty)
			if len(folder) == 0 {
				folder = group.GetAnnotation(groupProperty)
				if len(folder) == 0 {
					continue
				}
			}
			importSet.Add(fmt.Sprintf("%s \"%s\"", toPrefix(folder),
				pathx.JoinPackages(parentPkg, handlerDir, folder)))
		}
	}
	imports := importSet.Keys()
	sort.Strings(imports)
	projectSection := strings.Join(imports, "\n\t")
	var depSection string
	if hasMiddleware {
		depSection = fmt.Sprintf("\"%s\"", pathx.JoinPackages(parentPkg, middlewareDir))
	}
	return fmt.Sprintf("%s\n\n\t%s", projectSection, depSection)
}

func getRoutes(api *spec.ApiSpec) ([]group, error) {
	var routes []group

	for _, g := range api.Service.Groups {
		var groupedRoutes group
		for _, r := range g.Routes {
			handler := getHandlerName(r)
			handler = handler + "(serverCtx)"
			folder := r.GetAnnotation(groupProperty)
			if len(folder) > 0 {
				handler = toPrefix(folder) + "." + strings.ToUpper(handler[:1]) + handler[1:]
			} else {
				folder = g.GetAnnotation(groupProperty)
				if len(folder) > 0 {
					handler = toPrefix(folder) + "." + strings.ToUpper(handler[:1]) + handler[1:]
				}
			}
			groupedRoutes.routes = append(groupedRoutes.routes, route{
				method:  mapping[r.Method],
				path:    r.Path,
				handler: handler,
			})
		}

		groupedRoutes.timeout = g.GetAnnotation("timeout")
		groupedRoutes.maxBytes = g.GetAnnotation("maxBytes")

		jwt := g.GetAnnotation("jwt")
		if len(jwt) > 0 {
			groupedRoutes.authName = jwt
			groupedRoutes.jwtEnabled = true
		}
		jwtTrans := g.GetAnnotation(jwtTransKey)
		if len(jwtTrans) > 0 {
			groupedRoutes.jwtTrans = jwtTrans
		}

		signature := g.GetAnnotation("signature")
		if signature == "true" {
			groupedRoutes.signatureEnabled = true
		}
		sse := g.GetAnnotation("sse")
		if sse == "true" {
			groupedRoutes.sseEnabled = true
		}
		middleware := g.GetAnnotation("middleware")
		if len(middleware) > 0 {
			groupedRoutes.middlewares = append(groupedRoutes.middlewares,
				strings.Split(middleware, ",")...)
		}
		prefix := g.GetAnnotation(spec.RoutePrefixKey)
		prefix = strings.ReplaceAll(prefix, `"`, "")
		prefix = strings.TrimSpace(prefix)
		if len(prefix) > 0 {
			prefix = path.Join("/", prefix)
			groupedRoutes.prefix = prefix
		}
		routes = append(routes, groupedRoutes)
	}

	return routes, nil
}

func toPrefix(folder string) string {
	return strings.ReplaceAll(folder, "/", "")
}

func formatDuration(duration time.Duration) string {
	if duration < time.Microsecond {
		return fmt.Sprintf("%d * time.Nanosecond", duration.Nanoseconds())
	}
	if duration < time.Millisecond {
		return fmt.Sprintf("%d * time.Microsecond", duration.Microseconds())
	}
	return fmt.Sprintf("%d * time.Millisecond", duration.Milliseconds())
}
